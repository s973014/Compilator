# Текстовый редактор с языковым процессором

## Описание
Данная программа представляет собой текстовый редактор с возможностью анализа введённого текста с помощью встроенного языкового процессора. Программа включает стандартные функции редактирования текста, а также инструменты для работы с файлами, настройки интерфейса и отображения результатов анализа кода.

## Основные функции
### Работа с файлами:
- **Создать** – создаёт новый текстовый документ (не сохраняется автоматически).
- **Открыть** – загружает текстовый файл, выбранный пользователем.
- **Сохранить** – сохраняет текущий файл, если он уже существует; в противном случае открывается диалоговое окно для сохранения.
- **Сохранить как...** – открывает диалоговое окно для выбора имени и места сохранения файла.
- **Закрыть файл** – закрывает текущий документ; при наличии несохранённых изменений предлагает их сохранить.
- **Выход** – завершает работу программы; если есть несохранённые файлы, предлагает их сохранить.

### Редактирование текста:
- **Отменить** – отменяет последнее действие.
- **Повторить** – повторяет последнее действие.
- **Вырезать** – удаляет выделенный текст и помещает его в буфер обмена.
- **Копировать** – копирует выделенный текст в буфер обмена.
- **Вставить** – вставляет текст из буфера обмена в текущий документ.
- **Удалить** – удаляет выделенный текст без сохранения в буфер обмена.
- **Выделить всё** – выделяет весь текст в документе.

### Дополнительные функции:
- **Пуск** – запускает анализатор текста, который проверяет введённый код на ошибки и выводит результаты в области отображения.
- **Быстрые команды** – панель с кнопками для быстрого доступа к основным функциям (создание, открытие, сохранение, отмена, копирование, пуск и др.).
- **Параметры** – настройки программы, включая выбор размера текста (10, 11, 12, 14, 16, 18, 20) и языка интерфейса (русский, английский).
- **Справка** – открывает раздел справки с описанием всех функций программы.
- **О программе** – показывает информацию о версии программы и разработчике.

## Интерфейс
Программа состоит из нескольких ключевых областей:
1. **Область ввода/редактирования текста** – основная зона для работы с текстом. Позволяет вводить и редактировать текст, применять команды редактирования.
2. **Область отображения результатов работы языкового процессора** – отображает ошибки и предупреждения после нажатия кнопки «Пуск». Ввод текста в этой области запрещён.
3. **Панель инструментов** – содержит кнопки быстрых команд для удобного управления программой.

## Грамматика
```ebnf
G[START]:
1. <START> -> 'const'<SPACE>
2. <SPACE> -> '_'<FIRST>
3. <FIRST> -> StartSymbols<VAR>
4. <VAR> -> Name<VARREM>
5. <VARREM> -> Name<VARREM>
6. <VARREM> -> ':'<TYPE>
7. <TYPE> -> 'integer'<EQUAL>
8. <EQUAL> -> '='<NUMBER>
9. <NUMBER> -> '+'<UNSIGNEDNUM>
10. <NUMBER> -> '-'<UNSIGNEDNUM>
11. <NUMBER> -> digit <NUMBERREM>
12. <UNSIGNEDNUM> -> digit <NUMBERREM>
13. <NUMBERREM> -> digit <NUMBERREM>
14. <NUMBERREM> -> ';'

StartSymbols -> 'a'|'b'|'c'|...|'z'|'A'|'B'|'C'|...|'Z'|'_'
Name -> 'a'|'b'|'c'|...|'z'|'A'|'B'|'C'|...|'Z'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|'0'|'_'
Digit -> '1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|'0'

Z = <START>;
VT = {a,b,c,...,z,A,B,C,...,Z,_,=,+,-,;,0,1,2,...,9};
VN = {<START>,<SPACE>,<VAR>,<FIRST>,<VARREM>,<TYPE>,<EQUAL>,<NUMBER>,<UNSIGNEDNUM>,<NUMBERREM>};
```

Согласно классификации Хомского грамматика ``` G[START] ``` является автоматной. 

## Примеры допустимых строк

```Pascal
const n:integer = 12;
const QWE : integer= 1233;
const abc :integer=99;
```

## Диаграмма состояний сканера

![Image alt](https://github.com/s973014/imgs/blob/main/Syntax%20analyzer.png)

## Тестовые примеры
```Pascal
const n:integer = 12;
```
![Alt-текст](https://github.com/s973014/imgs/blob/main/Example1.PNG)
  
```Pascal
Const Int:integer= 10;
```
![Alt-текст](https://github.com/s973014/imgs/blob/main/Example2.PNG)
  
```Pascal
const a:integer = 1;
const b:integer = 2;
```
![Alt-текст](https://github.com/s973014/imgs/blob/main/Example3.PNG)

## Использование
1. Откройте или создайте новый текстовый документ.
2. Введите текст в область редактирования.
3. Используйте команды редактирования, если необходимо.
4. Запустите анализатор текста, нажав «Пуск».
5. Ознакомьтесь с результатами в области отображения ошибок.
6. Сохраните изменения перед закрытием программы.

## Лабораторная работа 5. Поддержка грамматики выражений G[E] и генерация ПОЛИЗ
В рамках расширения функциональности редактора реализована возможность анализа арифметических выражений по КС-грамматике G[<E>], а также генерации их внутреннего представления в виде польской инверсной записи (ПОЛИЗ).
```ebnf
1. E → T A  
2. A → ε | + T A | - T A  
3. T → O B  
4. B → ε | * O B | / O B  
5. O → num | ( E )  
6. num → digit {digit}
```
## Описание:
1. Реализация парсера: грамматика реализована методом рекурсивного спуска.
2. Лексический анализ: перед синтаксическим анализом производится разбор на лексемы (числа, операторы, скобки).
3. Синтаксический анализ: производится проверка корректности введённого выражения согласно правилам грамматики.
4. Генерация ПОЛИЗ: при успешном синтаксическом анализе строится выражение в форме обратной польской записи, пригодное для интерпретации.
## Обработка ошибок:
- **При обнаружении ошибки в структуре выражения** (например, пропущенной закрывающей скобке или неверном расположении оператора), анализатор выдаёт соответствующее сообщение с указанием позиции.
- **Лексические ошибки** (например, недопустимые символы) также выявляются и отображаются в области результатов.
## Использование:
1. Введите арифметическое выражение в окно редактора.
2. Нажмите кнопку «ПОЛИЗ».
3. В области результатов отобразятся:
- **Лексемы и их типы.**
- **Сообщения об ошибках (при наличии).**
- **Построенное выражение в виде ПОЛИЗ (если ошибок нет).**
# Реализация алгоритма поиска подстрок с помощью регулярных выражений.
### Лабораторная работа 6. 
Поставнока задачи - Реализовать алгоритм поиска в тексте подстрок, соответствующих заданным регулярным выражениям. Используя библиотечные реализации (например, класс Regex в C#), решить 3 задачи в соответствии с персональным вариантом.
Необходимо встроить разработанные алгоритмы в интерфейс текстового редактора, разработанного на первой лабораторной работе. 
Исходные данные – текст, содержащий данные заданного формата. Выходные данные – найденные выражения с указанием позиции начала. Возможно выделение подстрок в исходном тексте. (Задания: 29, 9, 5)
### Решение трёх задач:
1. Поиск цитат в кавычках (русские и английские кавычки) <br>
Решение:<br>
```
"[\"“”«»](.*?)[\"“”«»]"
```
2. Поиск номеров карт "Мир": начинаются с 2200–2204 и всего 16 цифр<br>
Решение:<br>
```
"\b(220[0-4]\d{12})\b"
```
3. Поиск дат в формате DD/MM/YYYY с проверкой високосных лет<br>
Решение:<br>
```
@"\b(?:(?:31/(?:0?[13578]|1[02]))|(?:29|30)/(?:0?[13-9]|1[0-2]))/((?:19|20)\d{2})" +
@"|(?:29/0?2/((?:(?:19|20)(?:[02468][048]|[13579][26]))))" +
@"|(?:0?[1-9]|1\d|2[0-8])/(?:0?[1-9]|1[0-2])/((?:19|20)\d{2})\b"
```
### Тестовые примеры:
![image](https://github.com/user-attachments/assets/7d51e0ab-9ce6-4496-8d08-bffd24d1758f)
![image](https://github.com/user-attachments/assets/9d3384b7-9810-4b10-8e7f-15138a6c9915)
![image](https://github.com/user-attachments/assets/e54c242a-f87d-48df-8463-d5ce0422e243)

# Лабораторная работа 7.Преобразование и анализ кода с использованием Clang и LLVM.
Цель работы: Познакомиться с инструментами Clang и LLVM, научиться собирать AST и IR-промежуточное представление кода на C/C++, а также извлекать базовую информацию о программе (например, список функций). Задачи:

1. Установить Clang и LLVM;
2. Скомпилировать простой C-файл с использованием clang и получить его: абстрактное синтаксическое дерево (AST), промежуточное представление LLVM IR;
3. Использовать opt для применения базовой комплексной оптимизации (например, О2);
4. Построить граф потока управления (CFG) для оптимизированной программы;
5. Проанализировать результат, сделать выводы и ответить на контрольные вопросы

## 1. Установка и подготовка среды
Работа выполнялась в среде Ubuntu 22.04. Установлены следующие
инструменты:<br>
● clang — компилятор языка C/C++;<br>
● llvm — инструменты анализа и оптимизации кода;<br>
● opt — инструмент для работы с LLVM IR и применения оптимизаций;<br>
● Graphviz — инструмент для визуализации кода.<br>
Команда установки: sudo apt install clang llvm
![1](https://github.com/user-attachments/assets/2c33fae2-cd20-4789-8329-d6e5bf8131ec)

## 2. Исходный код
Программа на языке C:
```
#include <stdio.h>
int square(int x) {
 return x * x;
}
int main() {
 int a = 5;
 int b = square(a);
 printf("%d\n", b);
 return 0;
}
```
Сохранена в файл main.c
![2](https://github.com/user-attachments/assets/c163435a-3d66-4b52-a6ac-5a5d0e6607ef)

## 3. Получение AST
Команда: clang -Xclang -ast-dump -fsyntax-only main.c
![3](https://github.com/user-attachments/assets/c0697fc2-7bf8-4314-99cb-09dbed466892)
Функция square принята, содержит параметр x и возвращает x * x.

## 4. Генерация LLVM IR
Команда: clang -S -emit-llvm main.c -o main.ll
![4](https://github.com/user-attachments/assets/d33bc120-a7ba-409f-bffe-f9e7c9f29059)

## 5. Оптимизация IR
Команда: clang -O0 -S -emit-llvm main.c -o main_O0.ll<br>
Стоит отметить, что в файле с IR до оптимизации:<br>
Все переменные (a, b, x.addr) размещены в памяти через alloca;<br>
Множество операций load и store;<br>
square вызывается как отдельная функция.<br>
![5_1](https://github.com/user-attachments/assets/94bc885b-1367-4dad-83cb-87e4ad6bc76b)

Команда: clang -O2 -S -emit-llvm main.c -o main_O2.ll

Команда -O2 – комплексная оптимизация среднего уровня. Она
применяет более 30 различных оптимизаций:<br>
● -inline – встраивание небольших функций (встраивает square в
main, если она вызывается один раз);<br>
● -constprop – подставит значение square(5) → 25, если функция
встроена и всё известно на этапе компиляции;<br>
● -mem2reg – перевод переменных из памяти в регистры (SSA);<br>
● -instcombine – объединение и упрощение инструкций
(упростит арифметику, например x * x может быть преобразовано в shl при
x = 2^n);<br>
● -simplifycfg – оптимизирует структуру блоков (Упростит граф
управления, если после inlining останутся лишние блоки);<br>
● -reassociate, -gvn, -sroa, -dce и другие.<br>
В файле с IR после оптимизации:<br>
Вся функция square исчезла – она была встроена (-inline) и затем
вычислена (оптимизация -constprop);<br>
Никаких переменных, alloca, store, load – всё удалено (оптимизации
-mem2reg, -dce);<br>
Остался только вызов printf(25)

![5_2](https://github.com/user-attachments/assets/271d2c20-7362-4e6a-97bc-d23874b59979)

Команда: diff main_O0.ll main_O2.ll<br>
Сравнение двух файлов:
![5_3](https://github.com/user-attachments/assets/9567381a-54f7-4494-8c65-10f162caa7c0)
Стоит отметить, что после оптимизации произошли следующие
изменения:<br>
● Переменные типа alloca были удалены;<br>
● Код переведён в SSA-форму;<br>
● Оптимизация улучшила читаемость и упростила поток
управления<br>

## 6. Граф потока управления программы
Команда для генерации оптимизированного LLVM IR: clang -O2 -S -emit-llvm main.c -o main.ll<br>
Команда для генерации .dot-файлов CFG для функций: opt -dot-cfg -disable-output main.ll
![6_1](https://github.com/user-attachments/assets/b76daf80-5793-4f32-ae77-393191e432a9)<br>
Эта команда создаст DOT-файлы: .main.dot – для функции main;<br>
.square.dot – для square, если она не была удалена оптимизацией.<br>
Команда для установки библиотеки Graphviz: sudo apt install graphviz<br>
Команды для преобразования файлов с расширением .dot в .png с<br>
помощью Graphviz:<br>
dot -Tpng .main.dot -o cfg_main.png<br>
dot -Tpng .square.dot -o cfg_square.png<br>
Команды для просмотра файлов с CGF:<br>
xdg-open cfg_main.png<br>
![6_2](https://github.com/user-attachments/assets/aed491dd-6c8a-40b4-88db-cf8d1c97316c)<br>
xdg-open cfg_square.png<br>
![6_3](https://github.com/user-attachments/assets/e4508186-a899-48e8-8b0f-abe40204797f)

Стоит отметить, что в LLVM каждый граф потока управления (CFG)
строится на уровне функции, поскольку структура управления всегда
локальна для тела функции. Для получения полного представления о
программе, нужно построить CFG для всех функций и анализировать их
совокупность. Автоматическое объединение всех CFG в один граф не
предусмотрено в LLVM по умолчанию.

Выводы:<br>
● С помощью Clang можно получить полную структуру AST и
IR, а также CGF;<br>
● LLVM предоставляет гибкие инструменты анализа и
оптимизации;<br>
● Промежуточное представление кода удобно для написания
компиляторных трансформаций.<br>

## Ответы на контрольные вопросы:
1. Что такое Clang и какова его функция в процессе компиляции?<br>
Clang — это компилятор, поддерживающий языки C, C++, Objective-C и другие. Он основан на LLVM и отвечает за начальные стадии компиляции: обрабатывает исходный код, создаёт его синтаксическую структуру (AST), проверяет корректность, а затем преобразует в промежуточный код (LLVM IR), который далее используется для оптимизаций и создания машинного кода.

2. Что такое LLVM и какова его роль в современных компиляторах?<br>
LLVM — это гибкая и расширяемая система для создания компиляторов. Она предоставляет инструменты для анализа, оптимизации и генерации кода. Многие современные компиляторы используют LLVM в качестве backend’а, что упрощает поддержку различных архитектур и повышает эффективность работы программ.

3. Чем различаются AST и LLVM IR?<br>
AST (абстрактное синтаксическое дерево) — это представление исходного кода на уровне языка, сохраняющее его структуру. LLVM IR (промежуточное представление) — это универсальный низкоуровневый формат, ближе к машинному коду. AST нужен для начального анализа, а IR — для оптимизаций и генерации итогового кода.

4. Зачем нужно промежуточное представление (IR) в компиляции?<br>
IR служит промежуточным звеном между анализом исходного кода и генерацией машинного. Оно облегчает кроссплатформенную разработку, ускоряет внедрение оптимизаций и делает архитектуру компилятора более модульной и переиспользуемой.

5. Что делает alloca в LLVM IR и в чём её назначение?<br>
Инструкция alloca выделяет память в стеке функции, аналогично созданию локальных переменных. Такая память используется во время выполнения функции и автоматически освобождается при её завершении.

6. Зачем компиляторы оптимизируют код и какие цели при этом ставятся?<br>
Оптимизация кода позволяет сделать программу быстрее, уменьшить её размер, снизить энергопотребление и эффективнее использовать ресурсы. Главная задача — улучшить производительность без изменения результата работы программы.

7. Что такое SSA и почему это важно для оптимизации?<br>
SSA (статическое одноназначное представление) — формат, при котором каждая переменная имеет единственное присваивание. Это упрощает отслеживание зависимостей между переменными и позволяет эффективнее выполнять такие оптимизации, как удаление ненужного кода или вычисление значений на этапе компиляции.

8. Что такое CFG и как он помогает в анализе программ?<br>
Граф потока управления (CFG) показывает, как управление переходит от одного участка программы к другому. Он строится из базовых блоков кода и переходов между ними. CFG помогает компилятору понять возможные пути выполнения и оптимизировать код.

9. Как представлены арифметические операции в LLVM IR?<br>
Арифметика в LLVM IR задаётся командами вроде add, mul, sub, fadd и другими. Каждая операция указывает тип данных и создаёт новый результат. Например:
%res = add i32 %x, %y — сложение двух 32-битных целых чисел.

10. Почему функции в LLVM IR являются самостоятельными единицами анализа?<br>
Функции в IR оформлены как отдельные блоки, что упрощает их анализ и улучшает точность оптимизаций. Это позволяет, например, удалять неиспользуемые функции или заменять их встраиванием в другие части программы.

11. Что делает компилятор с короткой функцией, вызываемой один раз?<br>
Если функция небольшая и вызывается один раз, компилятор часто встраивает её код (инлайнит) в место вызова. Это снижает затраты на вызов функции и улучшает последующую оптимизацию кода.

12. Почему IR и CFG дают преимущество по сравнению с анализом кода на C?<br>
IR и CFG представляют программу в унифицированной и упрощённой форме, без сложностей синтаксиса языка. Это делает автоматический анализ и оптимизации более надёжными, переносимыми и применимыми ко многим языкам, в отличие от разбора текста на C, где сложнее точно интерпретировать структуру и поведение кода.

## Дополнительное задание. Вариант 5
Задание: Определите const int LIMIT = 100; и используй в условии.
Проверьте, была ли подставлена константа при оптимизации -constprop
или -O2<br>
Исходный код:
```
#include <iostream>

int main() {
    const int LIMIT = 100;
    int x = 150;
    if (x > LIMIT) {
        std::cout << "x is greater than LIMIT\n";
    }
    return 0;
}
```
Генерация LLVM IR:<br>
Команда: clang++ -S -emit-llvm limit.cpp -o limit.ll
![11](https://github.com/user-attachments/assets/e980656a-d6b8-46e2-90b5-39e93c781165)
### Оптимизация среднего уровня (-O2):<br>
Команда: opt -O2 limit.ll -S -o limit_opt.ll<br>
![image](https://github.com/user-attachments/assets/becd1b87-2998-4722-b9a8-b625cfe2798d)<br>
Подстановка произошла.<br>
### Вывод
Использование const int LIMIT = 100; позволяет компилятору подставить 100 напрямую. При оптимизации -O2, Clang/LLVM действительно выполняет подстановку. Это можно проверить, заглянув в оптимизированный IR-файл (.ll) и убедившись, что вместо переменной используется литерал.

# Лабораторная работа 8.Реализация метода рекурсивного спуска для синтаксического анализа.
Цель работы: Разработать для грамматики алгоритм синтаксического анализа на основе метода рекурсивного спуска.<br>
Задание: В соответствии с вариантом для заданной грамматики необходимо разработать и реализовать алгоритм синтаксического анализа на основе метода рекурсивного спуска.<br>
Вариант 22:
```
G[expression]:
1. expression := multExpression | powExpression | expression ('+'|'-')
multExpression | expression ('+'|'-') powExpression
2. multExpression := ID | multExpression ('*'|'/') ID
3. powExpression := ID '^' powExpression | ID
ID – идентификатор Б{Б|Ц}, Б – {a, b, c, ...z, A, B, …, Z}, NUM – {0, 1, …, 9}
```
### Описание грамматики
Грамматика G[expression] задаёт синтаксис для выражений с операциями возведения в степень (^), умножения и деления (*, /), а также сложения и вычитания (+, -) с операндами в виде идентификаторов.<br>
### Классификация по Хомскому
Грамматика относится к контекстно-свободным (КС-грамматикам) (тип 2 по Хомскому), так как все правила имеют форму A → α, где A — нетерминал, а α — любая последовательность терминалов и/или нетерминалов.
### Схема вызовов функций
![image](https://github.com/user-attachments/assets/0adb34c4-5bcc-447b-b3d9-5377a58ee11a)

### Примеры работы программы
![image](https://github.com/user-attachments/assets/a2b99c76-5596-405f-a36e-b3b41ba04e04)
![image](https://github.com/user-attachments/assets/61dc1b04-e3cf-4586-8d32-5b167248a042)
![image](https://github.com/user-attachments/assets/bd75d51a-b99e-435e-96d1-b19ff92f6c33)
![image](https://github.com/user-attachments/assets/c7284171-6475-4631-92df-fd05d2e78446)
![image](https://github.com/user-attachments/assets/ad08daa6-cc33-4cde-8ba0-a9abd3ea47e8)
![image](https://github.com/user-attachments/assets/b110496b-258a-49bc-bcc3-450a402ba7b3)


